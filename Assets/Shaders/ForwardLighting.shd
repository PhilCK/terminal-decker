
Forward Lighting
----------------



[VERTEXSHADER]

#version 150 core

// Vertex Format
in vec3 inPosition;
in vec2 inTexC;
in vec3 inNormal;

uniform mat4 worldMat;
uniform mat4 viewMat;
uniform mat4 projMat;
//uniform mat4 normMat;

uniform vec3 eyePos;

out vec3 normal;
out vec3 toLight;
out vec3 toCamera;
out vec2 texC;

const vec3 lightPos = vec3(0.0,1.0,0.0);

void main()
{
    mat4 viewModel = worldMat * viewMat;
    mat4 normalMat = transpose(inverse(viewModel));

    vec4 pos = viewModel * vec4(inPosition, 1.0);

    normal = normalize(normalMat * vec4(inNormal, 1.0)).xyz;
    toLight = vec3(lightPos - pos.xyz);
    toCamera = vec3(-pos.x, -pos.y, -pos.z);

    mat4 wvp = projMat * viewMat * worldMat;
    gl_Position = wvp * vec4(inPosition, 1.0);

    texC = inTexC;

    // vec4 worldPosition = worldMat * vec4(inPosition, 1.0);

    // mat4 modelView = worldMat * viewMat;
    // mat4 normalMat = transpose(inverse(modelView));

    // normal = normalize(normalMat * vec4(inNormal, 1.0)).xyz;

    // toLight = normalize(lightPos - worldPosition.xyz);

    // toCamera = normalize(eyePos - worldPosition.xyz);

    // gl_Position = projMat * viewMat * worldPosition;

    texC = inTexC;
}


[/VERTEXSHADER]


[PIXELSHADER]

#version 150 core

in vec3 normal;
in vec3 toLight;
in vec3 toCamera;
in vec2 texC;

uniform sampler2D diffuseTex;

out vec4 outputColor;   

// parameters of the light and possible values
const vec3 u_lightAmbientIntensity = vec3(0.6, 0.3, 0);
const vec3 u_lightDiffuseIntensity = vec3(0.2, 0.5, 0.2);
const vec3 u_lightSpecularIntensity = vec3(1, 1, 1);

// parameters of the material and possible values
const vec3 u_matAmbientReflectance = vec3(1, 1, 1);
const vec3 u_matDiffuseReflectance = vec3(1, 1, 1);
const vec3 u_matSpecularReflectance = vec3(1, 1, 1);
const float u_matShininess = 64;


// returns intensity of reflected ambient lighting
vec3 ambientLighting()
{
   return u_matAmbientReflectance * u_lightAmbientIntensity;
}

// returns intensity of diffuse reflection
vec3 diffuseLighting(in vec3 N, in vec3 L)
{
   // calculation as for Lambertian reflection
   float diffuseTerm = clamp(dot(N, L), 0, 1);
   return u_matDiffuseReflectance * u_lightDiffuseIntensity * diffuseTerm;
}

// returns intensity of specular reflection
vec3 specularLighting(in vec3 N, in vec3 L, in vec3 V)
{
   float specularTerm = 0;

   // calculate specular reflection only if
   // the surface is oriented to the light source
   if(dot(N, L) > 0)
   {
      // half vector
      vec3 H = normalize(L + V);
      specularTerm = pow(dot(N, H), u_matShininess);
   }
   return u_matSpecularReflectance * u_lightSpecularIntensity * specularTerm;
}

void main()
{
   vec4 texColor = texture(diffuseTex, texC);

   // normalize vectors after interpolation
   // vec3 L = normalize(toLight);
   // vec3 V = normalize(toCamera);
   // vec3 N = normalize(normal);

   // // get Blinn-Phong reflectance components
   // float Iamb = ambientLighting();
   // float Idif = diffuseLighting(N, L);
   // float Ispe = specularLighting(N, L, V);

   // // diffuse color of the object from texture
   // //vec3 diffuseColor = texture(u_diffuseTexture, o_texcoords).rgb;

   // // combination of all components and diffuse color of the object
   // outputColor.xyz = texColor.rgb * (Iamb + Idif + Ispe);
   // outputColor.a = 1;

    //outputColor = texColor;

   vec4 spec = vec4(0.0);
   vec3 N = normalize(normal);
   vec3 L = normalize(toLight);
   vec3 E = normalize(toCamera);

   float intensity = max(dot(N, L), 0.0);
   if(intensity > 0.0)
   {
      vec3 H = normalize(L + E);
      float intSpec = max(dot(H, N), 0.0);
      vec4 specular = vec4(1,1,1,1);
      float shininess = 64;
      spec = specular * pow(intSpec, shininess);
   }

   vec4 diffuse = vec4(0.2, 0.2, 0.2, 1);
   vec4 ambient = vec4(0.2, 0.2, 0.2, 1);

   vec4 brighness = max(intensity * diffuse + spec, ambient);
   outputColor = texColor * brighness;
}

[/PIXELSHADER]
